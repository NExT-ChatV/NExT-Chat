{
    "summary": "This code provides utilities for bounding box manipulation, conversion between representations, and IoU calculation, including handling degenerate cases. It also computes bounding boxes from masks, calculates min/max coordinates in masked grids, and supports interpolation using torchvision or torch.nn.functional.",
    "details": [
        {
            "comment": "This code file contains utilities for bounding box manipulation and calculating Generalized Intersection over Union (GIoU). It defines functions for converting between center-size and corners representations of bounding boxes, and calculates the Intersection over Union (IoU) between two sets of bounding boxes. The generalized_box_iou function is a modified version of box_iou that also returns the union of bounding boxes.",
            "location": "\"/media/root/Prima/works/NExT-Chat/docs/src/mllm/utils/box_ops.py\":0-40",
            "content": "# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\"\"\"\nUtilities for bounding box manipulation and GIoU.\n\"\"\"\nimport torch\nfrom torchvision.ops.boxes import box_area\ndef box_cxcywh_to_xyxy(x):\n    x_c, y_c, w, h = x.unbind(-1)\n    b = [(x_c - 0.5 * w), (y_c - 0.5 * h),\n         (x_c + 0.5 * w), (y_c + 0.5 * h)]\n    return torch.stack(b, dim=-1)\ndef box_xyxy_to_cxcywh(x):\n    x0, y0, x1, y1 = x.unbind(-1)\n    b = [(x0 + x1) / 2, (y0 + y1) / 2,\n         (x1 - x0), (y1 - y0)]\n    return torch.stack(b, dim=-1)\n# modified from torchvision to also return the union\ndef box_iou(boxes1, boxes2):\n    area1 = box_area(boxes1)\n    area2 = box_area(boxes2)\n    lt = torch.max(boxes1[:, None, :2], boxes2[:, :2])  # [N,M,2]\n    rb = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])  # [N,M,2]\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    inter = wh[:, :, 0] * wh[:, :, 1]  # [N,M]\n    union = area1[:, None] + area2 - inter\n    iou = inter / union\n    return iou, union\ndef generalized_box_iou(boxes1, boxes2):\n    \"\"\""
        },
        {
            "comment": "Code from line 41 to 75 in \"NExT-Chat/mllm/utils/box_ops.py\" contains two functions: \"generalized_iou\" and \"masks_to_boxes\". The generalized_iou function calculates the Intersection over Union (IoU) between two sets of bounding boxes, taking care of degenerate boxes that may lead to inf/nan results. It returns a pairwise matrix of IoU values. The masks_to_boxes function takes input masks and computes bounding boxes around them, returning a tensor with shape [N, 4] in xyxy format, where N is the number of masks.",
            "location": "\"/media/root/Prima/works/NExT-Chat/docs/src/mllm/utils/box_ops.py\":41-75",
            "content": "    Generalized IoU from https://giou.stanford.edu/\n    The boxes should be in [x0, y0, x1, y1] format\n    Returns a [N, M] pairwise matrix, where N = len(boxes1)\n    and M = len(boxes2)\n    \"\"\"\n    # degenerate boxes gives inf / nan results\n    # so do an early check\n    assert (boxes1[:, 2:] >= boxes1[:, :2]).all()\n    assert (boxes2[:, 2:] >= boxes2[:, :2]).all()\n    iou, union = box_iou(boxes1, boxes2)\n    lt = torch.min(boxes1[:, None, :2], boxes2[:, :2])\n    rb = torch.max(boxes1[:, None, 2:], boxes2[:, 2:])\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    area = wh[:, :, 0] * wh[:, :, 1]\n    return iou - (area - union) / area\ndef masks_to_boxes(masks):\n    \"\"\"Compute the bounding boxes around the provided masks\n    The masks should be in format [N, H, W] where N is the number of masks, (H, W) are the spatial dimensions.\n    Returns a [N, 4] tensors, with the boxes in xyxy format\n    \"\"\"\n    if masks.numel() == 0:\n        return torch.zeros((0, 4), device=masks.device)\n    h, w = masks.shape[-2:]\n    y = torch.arange(0, h, dtype=torch.float)"
        },
        {
            "comment": "This code calculates the min and max x and y coordinates within a masked grid, then returns these values as a stacked tensor. The function is designed to work with empty batch sizes which may not be natively supported in some versions of PyTorch. It eventually aims to be replaced by native support in PyTorch.",
            "location": "\"/media/root/Prima/works/NExT-Chat/docs/src/mllm/utils/box_ops.py\":76-102",
            "content": "    x = torch.arange(0, w, dtype=torch.float)\n    y, x = torch.meshgrid(y, x)\n    x_mask = (masks * x.unsqueeze(0))\n    x_max = x_mask.flatten(1).max(-1)[0]\n    x_min = x_mask.masked_fill(~(masks.bool()), 1e8).flatten(1).min(-1)[0]\n    y_mask = (masks * y.unsqueeze(0))\n    y_max = y_mask.flatten(1).max(-1)[0]\n    y_min = y_mask.masked_fill(~(masks.bool()), 1e8).flatten(1).min(-1)[0]\n    return torch.stack([x_min, y_min, x_max, y_max], 1)\nfrom packaging import version\n# needed due to empty tensor bug in pytorch and torchvision 0.5\nimport torchvision\nif version.parse(torchvision.__version__) < version.parse('0.7'):\n    from torchvision.ops import _new_empty_tensor\n    from torchvision.ops.misc import _output_size\ndef interpolate(input, size=None, scale_factor=None, mode=\"nearest\", align_corners=None):\n    # type: (Tensor, Optional[List[int]], Optional[float], str, Optional[bool]) -> Tensor\n    \"\"\"\n    Equivalent to nn.functional.interpolate, but with support for empty batch sizes.\n    This will eventually be supported natively by PyTorch, and this"
        },
        {
            "comment": "This code checks the version of torchvision and performs interpolation on tensors. If the version is less than 0.7, it uses torch.nn.functional.interpolate, otherwise it uses torchvision.ops.misc.interpolate. If input has no elements, it returns an empty tensor with specified output shape.",
            "location": "\"/media/root/Prima/works/NExT-Chat/docs/src/mllm/utils/box_ops.py\":103-115",
            "content": "    class can go away.\n    \"\"\"\n    if version.parse(torchvision.__version__) < version.parse('0.7'):\n        if input.numel() > 0:\n            return torch.nn.functional.interpolate(\n                input, size, scale_factor, mode, align_corners\n            )\n        output_shape = _output_size(2, input, size, scale_factor)\n        output_shape = list(input.shape[:-2]) + list(output_shape)\n        return _new_empty_tensor(input, output_shape)\n    else:\n        return torchvision.ops.misc.interpolate(input, size, scale_factor, mode, align_corners)"
        }
    ]
}